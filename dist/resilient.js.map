{
  "version": 3,
  "sources": ["../src/shared.js", "../src/datastar.js", "../src/retryer.js", "../src/interceptor.js"],
  "sourcesContent": ["/**\n * A symbol key to access retryer sensitive methods.\n *\n * @warning If this key is used outside this library, it is at the user's own risk.\n * @constant {symbol}\n */\nexport const RETRYER_BYPASS_KEY = Symbol(\"unsafe\");\n\n/**\n * WeakMap that associates HTML elements with their Retryer instances.\n * Uses WeakMap to allow garbage collection when elements are removed from DOM.\n *\n * @type {WeakMap<HTMLElement, Retryer>}\n */\nexport const ElementIndex = new WeakMap();\n\n/**\n * Map that tracks fetch IDs to their associated elements.\n * Used by the Datastar plugin to correlate fetch requests with their originating elements.\n *\n * @type {Map<string, HTMLElement>}\n */\nexport const FetchIdToElement = new Map();\n\n/**\n * Event name fired when a reconnect attempt is initiated.\n * Dispatched before attempting to establish a connection.\n *\n * @constant {string}\n */\nexport const CONNECT_EVENT = \"connect\";\n\n/**\n * Event name fired when a connection is successfully established.\n * Indicates the SSE stream is ready and receiving data.\n *\n * @constant {string}\n */\nexport const CONNECTED_EVENT = \"connected\";\n\n/**\n * Event name fired when a connection is lost or disconnected.\n * Triggers automatic reconnection logic via the Retryer.\n *\n * @constant {string}\n */\nexport const DISCONNECTED_EVENT = \"disconnected\";\n\nexport class Logger {\n  constructor(enabled = false) {\n    this.enabled = enabled;\n  }\n\n  info(...args) {\n    if (this.enabled) console.info(...args);\n  }\n\n  warn(...args) {\n    if (this.enabled) console.warn(...args);\n  }\n\n  error(...args) {\n    console.error(...args);\n  }\n}\n\n/**\n * Parser and utility class for HTTP Content-Type headers.\n * Parses media types and parameters from Content-Type header strings.\n *\n * @example\n * const ct = new ContentType(\"text/html; charset=utf-8\");\n * ct.isHTML // true\n * ct.charset // \"utf-8\"\n */\nexport class ContentType {\n  /**\n   * Creates a new ContentType parser instance.\n   *\n   * @param {string} contentTypeString - The Content-Type header value to parse\n   */\n  constructor(contentTypeString) {\n    this.raw = contentTypeString || \"\";\n    this._parsed = this._parse();\n  }\n\n  /**\n   * Internal parser that extracts media type and parameters.\n   *\n   * @private\n   * @returns {{mediaType: string, params: Object}} Parsed media type and parameters\n   */\n  _parse() {\n    // Split by semicolon to separate media type from parameters\n    const parts = this.raw.split(\";\").map((p) => p.trim());\n    const mediaType = parts[0].toLowerCase();\n\n    // Parse parameters (e.g., charset=utf-8, boundary=...)\n    const params = {};\n    for (let i = 1; i < parts.length; i++) {\n      const [key, value] = parts[i].split(\"=\").map((s) => s.trim());\n      if (key && value) {\n        params[key.toLowerCase()] = value.replace(/^[\"']|[\"']$/g, \"\");\n      }\n    }\n\n    return { mediaType, params };\n  }\n\n  /**\n   * Gets the main type (e.g., \"text\" from \"text/html\").\n   *\n   * @returns {string} The main type\n   */\n  get type() {\n    return this._parsed.mediaType.split(\"/\")[0];\n  }\n\n  /**\n   * Gets the subtype (e.g., \"html\" from \"text/html\").\n   *\n   * @returns {string} The subtype\n   */\n  get subtype() {\n    return this._parsed.mediaType.split(\"/\")[1];\n  }\n\n  /**\n   * Gets all parsed parameters as an object.\n   *\n   * @returns {Object} Parameters object (e.g., {charset: \"utf-8\"})\n   */\n  get params() {\n    return this._parsed.params;\n  }\n\n  /**\n   * Checks if the content type is Server-Sent Events (text/event-stream).\n   *\n   * @returns {boolean} True if SSE\n   */\n  get isSSE() {\n    return this._parsed.mediaType === \"text/event-stream\";\n  }\n\n  /**\n   * Checks if the content type is JSON or a JSON variant (+json).\n   *\n   * @returns {boolean} True if JSON\n   */\n  get isJSON() {\n    return (\n      this._parsed.mediaType === \"application/json\" ||\n      this._parsed.mediaType.endsWith(\"+json\")\n    );\n  }\n\n  /**\n   * Checks if the content type is HTML.\n   *\n   * @returns {boolean} True if HTML\n   */\n  get isHTML() {\n    return this._parsed.mediaType === \"text/html\";\n  }\n\n  /**\n   * Checks if the content type is XML or an XML variant (+xml).\n   *\n   * @returns {boolean} True if XML\n   */\n  get isXML() {\n    return (\n      this._parsed.mediaType === \"application/xml\" ||\n      this._parsed.mediaType === \"text/xml\" ||\n      this._parsed.mediaType.endsWith(\"+xml\")\n    );\n  }\n\n  /**\n   * Checks if the main type is \"text\".\n   *\n   * @returns {boolean} True if text type\n   */\n  get isText() {\n    return this.type === \"text\";\n  }\n\n  /**\n   * Checks if the main type is \"multipart\".\n   *\n   * @returns {boolean} True if multipart type\n   */\n  get isMultipart() {\n    return this.type === \"multipart\";\n  }\n\n  /**\n   * Checks if the content type is multipart/form-data.\n   *\n   * @returns {boolean} True if form data\n   */\n  get isFormData() {\n    return this._parsed.mediaType === \"multipart/form-data\";\n  }\n\n  /**\n   * Checks if the content type is application/x-www-form-urlencoded.\n   *\n   * @returns {boolean} True if URL encoded form\n   */\n  get isFormURLEncoded() {\n    return this._parsed.mediaType === \"application/x-www-form-urlencoded\";\n  }\n\n  /**\n   * Checks if the content type is binary (not text, JSON, XML, or HTML).\n   *\n   * @returns {boolean} True if binary\n   */\n  get isBinary() {\n    return !this.isText && !this.isJSON && !this.isXML && !this.isHTML;\n  }\n\n  /**\n   * Gets the charset parameter, defaults to \"utf-8\" if not specified.\n   *\n   * @returns {string} The charset value\n   */\n  get charset() {\n    return this.params.charset || \"utf-8\";\n  }\n\n  /**\n   * Checks if the media type exactly matches the given type.\n   *\n   * @param {string} type - The media type to compare (case-insensitive)\n   * @returns {boolean} True if exact match\n   */\n  is(type) {\n    return this._parsed.mediaType === type.toLowerCase();\n  }\n\n  /**\n   * Checks if the media type matches a pattern.\n   * Supports RegExp or wildcard strings like \"text/*\" or \"* /json\".\n   *\n   * @param {string|RegExp} pattern - Pattern to match against\n   * @returns {boolean} True if matches pattern\n   */\n  matches(pattern) {\n    if (pattern instanceof RegExp) {\n      return pattern.test(this._parsed.mediaType);\n    }\n    // Support wildcards like \"text/*\" or \"*/json\"\n    const regex = new RegExp(\"^\" + pattern.replace(\"*\", \".*\") + \"$\");\n    return regex.test(this._parsed.mediaType);\n  }\n\n  /**\n   * Returns the original Content-Type header string.\n   *\n   * @returns {string} The raw Content-Type header value\n   */\n  toString() {\n    return this.raw;\n  }\n}\n", "/**\n * =============================================================================\n * IMPORTANT NOTICE: Undocumented Datastar API Usage\n * =============================================================================\n *\n * This file contains code that relies on UNDOCUMENTED and INTERNAL Datastar\n * mechanisms, including but not limited to:\n *\n *   - Dispatching custom Datastar events\n *   - Wrapping Datastar action plugins\n *   - Manipulating Datastar request headers and arguments\n *   - Accessing internal action implementations\n *\n * \u26A0\uFE0F THE DATASTAR API HAS NO STABILITY GUARANTEES AND MAY CHANGE AT ANY MOMENT \u26A0\uFE0F\n *\n * This code works by hooking into Datastar's API which may change or be\n * removed at any time in future versions without notice or backwards\n * compatibility. Breaking changes are likely when upgrading Datastar.\n *\n * COMPATIBILITY & VERSION REQUIREMENTS:\n *\n *   - This library aims to be compatible with the latest version of Datastar\n *   - Currently compatible with: v1.0.0-RC.6\n *   - For support with older versions (v1.0.0-RC.5), see MIGRATION.md\n *   - DO NOT upgrade Datastar without verifying compatibility\n *   - The maintainer will make efforts to keep this code compatible with new\n *     Datastar versions, but updates may lag behind Datastar releases\n *\n * Community contributions, pull requests, and compatibility updates for new\n * Datastar versions are more than welcome and greatly appreciated!\n *\n * =============================================================================\n */\n\nimport { ElementIndex, FetchIdToElement } from \"./shared.js\";\nimport { InterceptorLogger } from \"./interceptor.js\";\n\nconst DATASTAR_FETCH_EVENT = \"datastar-fetch\";\nconst DATASTAR_SIGNAL_PATCH_EVENT = \"datastar-signal-patch\";\n\nexport function FetchReturn(response, transformStream) {\n  // Create new response with transformed body\n  // IMPORTANT: This is compatible with Datastar's fetch handling because:\n  // 1. For SSE streams: Datastar uses response.body directly\n  //    - Our transformed stream works perfectly with getBytes(response.body)\n  // 2. For HTML/JSON: Datastar calls response.text()\n  //    - Response.text() works on our transformed ReadableStream\n  // 3. Response object properly exposes the transformed body through both\n  //    response.body (as ReadableStream) and response.text() (as Promise<string>)\n  const transformedBody = response.body.pipeThrough(transformStream);\n\n  return new Response(transformedBody, {\n    status: response.status,\n    statusText: response.statusText,\n    headers: new Headers(response.headers),\n  });\n}\n\nconst FetchIdHeader = \"X-Fetch-Id\";\n\n/**\n * Dispatches a custom event to update Datastar signals.\n *\n * @param {object} signals - An object where keys are signal names and values are the new signal values.\n */\nexport function SendSignal(signal) {\n  // The detail object simulates the structure of a datastar-patch-signals event.\n  const detail = {\n    type: \"datastar-patch-signals\",\n    argsRaw: {\n      signals: JSON.stringify(signal),\n    },\n  };\n\n  // Dispatch a 'datastar-fetch' event to be caught by the PatchSignals watcher.\n  document.dispatchEvent(new CustomEvent(DATASTAR_FETCH_EVENT, { detail }));\n}\n\n/**\n * Connection state values for Datastar signals.\n * Used with Retryer's enableDatastarSignals option.\n *\n * @constant\n * @type {{CONNECTING: string, CONNECTED: string, DISCONNECTED: string}}\n */\nexport const SIGNALS_CONNECTION_STATES = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n};\n\n// counter for generating unique fetch IDs\nlet fetchCounter = 0;\n\n// Store references to original fetch actions\n// const originalActions = {};\n\n/**\n * Wraps a Datastar fetch action to inject X-Fetch-Id headers and disable retries.\n * This wrapper executes on get and post requests (e.g., @get and @post calls).\n *\n * @param {Function} originalAction - The original action function\n * @returns {Function} The wrapped action function\n */\nfunction wrapFetchAction(originalAction) {\n  return async (ctx, url, args = {}) => {\n    // only modify elements with a Retryer instance\n    const hasRetryer = !!ElementIndex.get(ctx.el);\n    if (!hasRetryer) {\n      return originalAction(ctx, url, args);\n    }\n\n    const fetchId = `${++fetchCounter}`;\n    FetchIdToElement.set(fetchId, ctx.el);\n    // cleanup fallback: normally deleted immediately when fetch executes.\n    // this 5s timeout only fires if fetch never gets called (e.g., error before fetch starts).\n    setTimeout(() => FetchIdToElement.delete(fetchId), 5000);\n    args.headers = { ...args.headers, [FetchIdHeader]: fetchId };\n\n    // disable datastar built-in retry mechanism since we handle retries via the Retryer.\n    // setting retryMaxCount to 0 prevents any retries, but Datastar will still reject\n    // with an error, we catch and suppress this error below to avoid console spam.\n    args.retryMaxCount = 0;\n\n    try {\n      return await originalAction(ctx, url, args);\n    } catch (error) {\n      // suppress Datastar's FetchFailed errors since our Retryer handles reconnection.\n      if (error?.message?.startsWith(\"FetchFailed\")) {\n        InterceptorLogger.info(\n          `[Interceptor] Suppressed Datastar FetchFailed error, Retryer will handle reconnection for:`,\n          ctx.el\n        );\n        return; // resolve with undefined\n      }\n      throw error; // re-throw other errors\n    }\n  };\n}\n\n/**\n * Loads the Datastar plugin by wrapping fetch actions.\n * This must be called AFTER Datastar is imported but BEFORE any Datastar attributes are processed.\n *\n * @param {Object} datastarExports - The Datastar exports object containing { action, actions }\n * @param {Function} datastarExports.action - The action registration function from Datastar\n * @param {Object} datastarExports.actions - The actions object from Datastar\n *\n * @example\n * // Datastar v1.0.0-RC.6\n * import { action, actions } from 'datastar';\n * LoadDatastarPlugin({ action, actions });\n */\nexport function LoadDatastarPlugin(datastarExports) {\n  try {\n    const { action, actions } = datastarExports;\n\n    if (!action || !actions) {\n      throw new Error(\n        \"LoadDatastarPlugin requires { action, actions } from Datastar v1.0.0-RC.6. \" +\n        \"Import them from your Datastar bundle and pass them to LoadDatastarPlugin.\"\n      );\n    }\n\n    // wrap fetch actions\n    const fetchActions = [\"get\", \"post\"];\n\n    for (const actionName of fetchActions) {\n      const originalAction = actions[actionName];\n\n      if (!originalAction) {\n        throw new Error(\n          `[Resilient] Action '${actionName}' not found in Datastar. ` +\n          `Cannot wrap missing action.`\n        );\n      }\n\n      // save original for reference\n      // originalActions[actionName] = originalAction;\n\n      // register wrapped action\n      action({\n        name: actionName,\n        apply: wrapFetchAction(originalAction),\n      });\n\n      InterceptorLogger.info(`[Resilient] Wrapped Datastar action: ${actionName}`);\n    }\n\n    InterceptorLogger.info(\"[Resilient] Successfully loaded Datastar plugin\");\n  } catch (e) {\n    console.error(\"[Resilient] Failed to load DatastarPlugin:\", e);\n    throw e;\n  }\n}\n", "import {\n  RETRYER_BYPASS_KEY,\n  CONNECT_EVENT,\n  CONNECTED_EVENT,\n  DISCONNECTED_EVENT,\n  Logger,\n  ElementIndex,\n} from \"./shared.js\";\n\nimport { SendSignal, SIGNALS_CONNECTION_STATES } from \"./datastar.js\";\n\n/**\n * Creates a configurable exponential backoff calculator function\n * @param {Object} options - Backoff configuration options\n * @param {number} [options.maxInitialAttempts=3] - Maximum number of quick retries for initial connection\n * @param {number} [options.initialDelayMs=20] - Initial retry delay in milliseconds\n * @param {number} [options.maxDelayMs=30000] - Maximum delay cap in milliseconds\n * @param {number} [options.baseDelayMs=1000] - Base delay multiplier in milliseconds\n * @param {number} [options.baseMultiplier=2] - Base for exponential calculation\n * @returns {Function} Backoff calculator function\n */\nexport function SimpleBackoffCalculator({\n  maxInitialAttempts = 3,\n  initialDelayMs = 20,\n  maxDelayMs = 30000,\n  baseDelayMs = 1000,\n  baseMultiplier = 2,\n} = {}) {\n  let initialRetryCount = 0;\n\n  return function (retryCount, _, reconnections) {\n    // Handle initial connection attempts\n    if (reconnections === -1) {\n      initialRetryCount++;\n      if (maxInitialAttempts > 0 && initialRetryCount > maxInitialAttempts) {\n        return false;\n      }\n      return initialDelayMs;\n    }\n\n    // Calculate exponential backoff for reconnections\n    return Math.min(\n      maxDelayMs,\n      baseDelayMs * Math.pow(baseMultiplier, retryCount)\n    );\n  };\n}\n\n/**\n * Manages automatic reconnection for SSE connections with configurable backoff.\n * Tracks fetch lifecycle events and handles retry logic when connections fail.\n *\n * @param {HTMLElement} element - The element to attach the retryer to\n * @param {Object} [options={}] - Configuration options\n * @param {boolean} [options.debug=false] - Enable console logging, disabled by default.\n * @param {Function} [options.backoffCalculator] - Function that takes (retryCount, lastStartTime, reconnections) and returns delay in ms or false to stop retrying. retryCount is consecutive attempts, lastStartTime is timestamp of last attempt, reconnections is total successful connections (-1 = initial connection, 0+ = reconnections). Return false to stop reconnection attempts entirely. Default uses exponential backoff capped at 30s, with max 3 attempts for initial connection (reconnections === -1).\n * @param {Function} [options.isFailedRequest] - Function that takes (from fetch) response and returns boolean. Default is response.status >= 400 (https://data-star.dev/essays/im_a_teapot/)\n * @param {number} [options.inactivityTimeoutMs=0] - Time in ms to consider connection inactive if no data received, if value is 0 or not set, inactivity is not checked. Default is 0.\n * @param {boolean} [options.enableConnectionEvents=false] - Enable dispatching of CONNECTED_EVENT and DISCONNECTED_EVENT. Default is false. Note: CONNECT_EVENT is always dispatched regardless of this setting.\n * @param {string} [options.enableDatastarSignals=\"\"] - String key for Datastar signals. If set, sends signals with this key and values: \"connecting\", \"connected\", \"disconnected\". Default is empty (disabled).\n * @param {Function|null} [options.requestInterceptor=null] - Function to modify fetch requests before they execute. Takes ({ resource, init }) and returns { resource, init }. Resource can be string, URL, or Request object. Init is the optional RequestInit. Default is null (no modification).\n * @param {Function|null} [options.responseInterceptor=null] - Function to modify Response object before it's returned to Datastar. Takes ({ url, response }) and returns modified Response. Useful for modifying headers, status, etc. Default is null (no modification).\n * @param {Function|null} [options.dataInterceptor=null] - Function to modify streaming response data chunks. Takes ({ url, response, chunk }) and returns modified chunk. Chunk is a Uint8Array containing binary data. Called for each chunk of the response body. Default is null (no modification).\n */\nexport class Retryer {\n  #logger;\n\n  #lastStartTime;\n  #retryCount;\n  #retryTimer;\n  #connected;\n  #lastSSETime;\n  #abortController;\n  #reconnections;\n  #inactivityCheckInterval;\n\n  constructor(element, options = {}) {\n    // remove null and undefined values from options\n    options = Object.fromEntries(\n      Object.entries(options).filter(([_, value]) => value != null)\n    );\n\n    const defaults = {\n      debug: false,\n      backoffCalculator: SimpleBackoffCalculator(),\n      isFailedRequest: function (response) {\n        // https://data-star.dev/essays/im_a_teapot/\n        return response.status >= 400;\n      },\n      inactivityTimeoutMs: 0,\n      enableConnectionEvents: false,\n      enableDatastarSignals: \"\",\n      requestInterceptor: null, // function ({ resource, init }) => ({ resource, init })\n      responseInterceptor: null, // function ({ url, response }) => response\n      dataInterceptor: null, // function ({ url, response, chunk }) => chunk\n    };\n\n    this.element = element;\n    this.options = { ...defaults, ...options };\n    this.#logger = new Logger(this.options.debug);\n\n    this.#lastStartTime = null;\n    this.#retryCount = 0;\n    this.#retryTimer = null;\n    this.#connected = false;\n    this.#lastSSETime = null;\n    this.#abortController = null;\n    this.#reconnections = -1; // starts at -1, first successful connection sets to 0\n    this.#inactivityCheckInterval = null;\n\n    this.init();\n  }\n\n  init() {\n    ElementIndex.set(this.element, this);\n    this.notifyRequestStopped(RETRYER_BYPASS_KEY, true);\n  }\n\n  get lastStartTime() {\n    return this.#lastStartTime;\n  }\n\n  get connected() {\n    return this.#connected;\n  }\n\n  get reconnections() {\n    return this.#reconnections;\n  }\n\n  /**\n   * Sets the abort controller for the current request.\n   * Used by the fetch interceptor to enable request cancellation.\n   */\n  setAbortController(key, controller) {\n    this.#checkKey(key);\n\n    this.#abortController = controller;\n  }\n\n  /**\n   * Tracks SSE activity by updating the last activity timestamp.\n   * The automatic inactivity monitor will handle timeout detection.\n   */\n  trackSSE(key) {\n    this.#checkKey(key);\n\n    if (this.options?.inactivityTimeoutMs > 0) {\n      this.#lastSSETime = Date.now();\n    }\n  }\n\n  /**\n   * Starts automatic inactivity monitoring with periodic checks.\n   * Called when connection is established to auto-detect inactivity.\n   */\n  #startInactivityMonitor() {\n    if (this.options?.inactivityTimeoutMs <= 0) return;\n\n    this.#stopInactivityMonitor();\n\n    const checkIntervalMs = Math.min(\n      1000,\n      this.options.inactivityTimeoutMs / 2\n    );\n\n    this.#inactivityCheckInterval = setInterval(() => {\n      this.#logger.info(\n        `[Retryer] Inactivity monitor check, last SSE at: ${this.#lastSSETime}`\n      );\n\n      if (this.#lastSSETime === null) return;\n\n      const elapsed = Date.now() - this.#lastSSETime;\n      if (elapsed > this.options.inactivityTimeoutMs) {\n        this.#logger.warn(\n          `[Retryer] Auto-detected inactivity timeout (${this.options.inactivityTimeoutMs}ms), after ${elapsed}ms of no data, aborting connection for element:`,\n          this.element\n        );\n\n        const controller = this.#abortController;\n        this.#abortController = null; // clear before abort to prevent reuse\n        controller?.abort(\"[Retryer] Auto-aborted due to inactivity timeout\");\n\n        this.notifyRequestStopped(RETRYER_BYPASS_KEY);\n      }\n    }, checkIntervalMs);\n\n    this.#logger.info(\n      `[Retryer] Started inactivity monitor (checking every ${checkIntervalMs}ms) for element:`,\n      this.element\n    );\n  }\n\n  /**\n   * Stops the automatic inactivity monitoring interval.\n   */\n  #stopInactivityMonitor() {\n    if (this.#inactivityCheckInterval) {\n      clearInterval(this.#inactivityCheckInterval);\n      this.#inactivityCheckInterval = null;\n      this.#logger.info(\n        \"[Retryer] Stopped inactivity monitor for element:\",\n        this.element\n      );\n    }\n  }\n\n  #checkKey(key) {\n    if (key !== RETRYER_BYPASS_KEY) {\n      throw new Error(\n        \"[Retryer] Sensitive method called without RETRYER_BYPASS_KEY\"\n      );\n    }\n  }\n\n  /**\n   * Notifies the retryer that a fetch request has started.\n   * Called by the fetch interceptor when initiating a network request.\n   */\n  notifyRequestStarted(key) {\n    this.#checkKey(key);\n    this.#lastSSETime = Date.now();\n    this.#lastStartTime = Date.now();\n    this.#clearRetryTimer();\n    this.#logger.info(\"[Retryer] request started for element:\", this.element);\n    this.#startInactivityMonitor(); // Start automatic inactivity monitoring\n  }\n\n  /**\n   * Determines if a response should be treated as a failed request.\n   * Delegates to the user-configured isFailedRequest option.\n   */\n  isFailedRequest(key, response) {\n    this.#checkKey(key);\n    return this.options.isFailedRequest(response);\n  }\n\n  /**\n   * Notifies the retryer that a connection has been successfully established.\n   * Resets retry counters, dispatches events, and updates connection state.\n   */\n  notifyRequestConnected(key) {\n    this.#checkKey(key);\n\n    this.#connected = true;\n    this.#retryCount = 0;\n    this.#reconnections++;\n    this.#clearRetryTimer();\n    if (this.options.enableConnectionEvents) {\n      this.element.dispatchEvent(new Event(CONNECTED_EVENT));\n    }\n    if (this.options.enableDatastarSignals) {\n      SendSignal({\n        [this.options.enableDatastarSignals]:\n          SIGNALS_CONNECTION_STATES.CONNECTED,\n      });\n    }\n    this.#logger.info(\"[Retryer] request connected for element:\", this.element);\n  }\n\n  /**\n   * Notifies the retryer that a request has stopped or disconnected.\n   * Clears connection state, dispatches events, and optionally schedules reconnection.\n   */\n  notifyRequestStopped(key, retry = true) {\n    this.#checkKey(key);\n\n    // there is no state correlation with this.#connected to this method call,\n    // the real connected state is managed externally.\n    // (by the interceptor ot even network failures)\n    //\n    // this.#connected is just a flag to:\n    // - provide some protection against CONNECT_EVENT calls.\n    // - provide to the user a reference of the last known state (via isConnected())\n\n    this.#abortController = null; // clear to prevent further aborts\n    this.#connected = false;\n    this.#lastSSETime = null;\n    this.#stopInactivityMonitor();\n\n    if (this.options.enableConnectionEvents) {\n      this.element.dispatchEvent(new Event(DISCONNECTED_EVENT));\n    }\n    if (this.options.enableDatastarSignals) {\n      SendSignal({\n        [this.options.enableDatastarSignals]:\n          SIGNALS_CONNECTION_STATES.DISCONNECTED,\n      });\n    }\n    if (this.#reconnections > 0) {\n      this.#logger.info(\"[Retryer] request stopped for element:\", this.element);\n    }\n    if (retry) this.#scheduleReconnect();\n  }\n\n  #scheduleReconnect() {\n    // ignore if already retrying\n    if (this.#retryTimer) {\n      this.#logger.info(\n        \"[Retryer] reconnect already scheduled, skipping for element:\",\n        this.element\n      );\n      return;\n    }\n\n    // check if element is still in DOM\n    if (!document.body.contains(this.element)) {\n      this.#logger.warn(\n        \"[Retryer] element removed from DOM, not scheduling reconnect\"\n      );\n      return;\n    }\n\n    this.#retryCount++;\n\n    // schedule reconnect\n    const delayMs = this.options.backoffCalculator(\n      this.#retryCount,\n      this.#lastStartTime,\n      this.#reconnections\n    );\n\n    if (delayMs === false) {\n      this.#logger.error(\n        `[Retryer] retries exhausted, not scheduling reconnect for element:`,\n        this.element\n      );\n      this.notifyRequestStopped(RETRYER_BYPASS_KEY, false);\n      return;\n    }\n\n    this.#logger.warn(\n      `[Retryer] scheduling reconnect in ${delayMs}ms (retry #${\n        this.#retryCount\n      }) for element:`,\n      this.element\n    );\n\n    this.#retryTimer = setTimeout(() => {\n      this.#logger.info(\n        `[Retryer] executing scheduled reconnect (retry #${\n          this.#retryCount\n        }) for element:`,\n        this.element\n      );\n      this.#retryTimer = null;\n      this.#fireConnect();\n    }, delayMs);\n  }\n\n  #fireConnect() {\n    if (this.#connected) {\n      this.#logger.info(\n        \"[Retryer] already connected, not firing connect for element:\",\n        this.element\n      );\n      return;\n    }\n    this.element.dispatchEvent(new Event(CONNECT_EVENT));\n    if (this.options.enableDatastarSignals) {\n      SendSignal({\n        [this.options.enableDatastarSignals]:\n          SIGNALS_CONNECTION_STATES.CONNECTING,\n      });\n    }\n  }\n\n  // from here down: cleanup\n\n  #clearRetryTimer() {\n    if (this.#retryTimer) {\n      clearTimeout(this.#retryTimer);\n      this.#retryTimer = null;\n    }\n  }\n\n  /**\n   * Cleans up the retryer instance and removes it from the element index.\n   * Call this when the element is removed or the retryer is no longer needed.\n   */\n  destroy() {\n    this.#clearRetryTimer();\n    this.#stopInactivityMonitor();\n    ElementIndex.delete(this.element);\n    this.#logger.info(\"[Retryer] Destroyed for element:\", this.element);\n  }\n}\n\nwindow.Resilient = {\n  Retryer: Retryer,\n  GetRetryer: function (element) {\n    return ElementIndex.get(element);\n  },\n  SimpleBackoffCalculator: SimpleBackoffCalculator,\n};\n", "import {\n  RETRYER_BYPASS_KEY,\n  Logger,\n  ElementIndex,\n  FetchIdToElement,\n} from \"./shared.js\";\nimport { Retryer } from \"./retryer.js\";\nimport { FetchReturn } from \"./datastar.js\";\n\nconst FetchIdHeader = \"X-Fetch-Id\";\n\n/**\n * Logger instance for the fetch interceptor.\n * Use ToggleInterceptorLogging() to control output.\n *\n * @type {Logger}\n */\nexport const InterceptorLogger = new Logger(false);\n\n/**\n * Enables or disables console logging for the fetch interceptor.\n * Logs fetch lifecycle events, errors, and debug information.\n *\n * @param {boolean} enabled - true to enable logging, false to disable\n *\n * @example\n * ToggleInterceptorLogging(true);  // enable logging\n * ToggleInterceptorLogging(false); // disable logging\n */\nexport function ToggleInterceptorLogging(enabled) {\n  InterceptorLogger.enabled = enabled;\n}\n\n/**\n * Creates a TransformStream to process the response body stream.\n * Applies the dataInterceptor if configured, then enqueues chunks to the stream.\n *\n * @param {Object} params\n * @param {string} params.url\n * @param {Response} params.response\n * @param {Retryer|null} params.retryer\n * @returns {TransformStream} A TransformStream that processes chunks with optional data modification\n */\nconst fetchStreamTransformer = function ({ url, response, retryer }) {\n  return new TransformStream({\n    async transform(chunk, controller) {\n      retryer?.trackSSE(RETRYER_BYPASS_KEY);\n\n      try {\n        // allow user to modify received data\n        if (retryer?.options.dataInterceptor) {\n          chunk =\n            retryer.options.dataInterceptor({ url, response, chunk }) ?? chunk;\n        }\n\n        // return data to stream\n        controller.enqueue(chunk);\n      } catch (e) {\n        InterceptorLogger.error(\n          \"[Interceptor] Error in stream transformer:\",\n          e\n        );\n        controller.error(e);\n      }\n    },\n  });\n};\n\nconst originalFetch = window.fetch;\n\n/**\n * Intercepts all fetch requests to incorporate retry logic and request/response modification.\n * Only requests associated with a Retryer instance are affected.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch\n *\n * @param {string | URL | Request} resource - The URL or Request object to fetch\n * @param {RequestInit} [init] - Fetch options (optional)\n * @returns {Promise<Response>} The fetch response with (optionally) transformed response\n */\nwindow.fetch = async function (resource, init) {\n  const { retryer } = getRetryer(resource, init);\n\n  if (!retryer) {\n    InterceptorLogger.info(\n      \"[Interceptor] No Retryer associated with fetch, calling original fetch.\"\n    );\n    return originalFetch(resource, init);\n  }\n\n  InterceptorLogger.info(\n    \"[Interceptor] Intercepted fetch with Retryer:\",\n    retryer\n  );\n\n  if (retryer.options.requestInterceptor) {\n    ({ resource, init } = retryer.options.requestInterceptor({\n      resource,\n      init,\n    }));\n  }\n\n  const isRequestObject = resource instanceof Request;\n  const url = isRequestObject ? resource.url : resource;\n\n  // create a new abort controller to manage fetch abortion\n  const abortController = new AbortController();\n\n  // if there is an original signal, listen to it and forward the abort\n  if (init?.signal) {\n    init.signal.aborted\n      ? abortController.abort(init.signal.reason)\n      : init.signal.addEventListener(\n          \"abort\",\n          () => abortController.abort(init.signal.reason),\n          { once: true }\n        );\n  }\n\n  const newOptions = { ...init, signal: abortController.signal };\n\n  let response;\n\n  retryer.notifyRequestStarted(RETRYER_BYPASS_KEY);\n  retryer.setAbortController(RETRYER_BYPASS_KEY, abortController);\n\n  try {\n    // Call originalFetch with the appropriate parameters\n    if (isRequestObject) {\n      // For Request objects, we may have recreated it with modifications\n      // Pass the (possibly new) Request object with merged options\n      response = await originalFetch(resource, newOptions);\n    } else {\n      // For url/options, pass them directly\n      response = await originalFetch(url, newOptions);\n    }\n\n    if (retryer.isFailedRequest(RETRYER_BYPASS_KEY, response)) {\n      // abort to let the server server know we are giving up on this request\n      abortController.abort(\n        \"[Interceptor] Fetch aborted by retryer: unexpected response\"\n      );\n\n      InterceptorLogger.warn(\n        `[Interceptor] Fetch aborted by retryer: unexpected response for ${url}`,\n        response\n      );\n\n      // throw to inform of failure\n      throw new Error(\n        \"[Interceptor] Fetch aborted by retryer: unexpected response\"\n      );\n    } else {\n      retryer.notifyRequestConnected(RETRYER_BYPASS_KEY);\n    }\n  } catch (e) {\n    retryer.notifyRequestStopped(RETRYER_BYPASS_KEY);\n    throw e;\n  }\n\n  InterceptorLogger.info(\n    `[Interceptor] fetch response: ${response.status} ${response.statusText} for ${url}`,\n    response\n  );\n\n  if (retryer.options.responseInterceptor) {\n    response =\n      retryer.options.responseInterceptor({ url, response }) ?? response;\n  }\n\n  if (!response.body) {\n    InterceptorLogger.info(\n      \"[Interceptor] response has no body, skipping transformation, for url:\",\n      url\n    );\n\n    return response;\n  }\n\n  const transformStream = fetchStreamTransformer({\n    url,\n    response,\n    retryer,\n  });\n\n  return FetchReturn(response, transformStream);\n};\n\n/**\n * Extracts the Retryer instance from fetch parameters.\n * Handles both regular fetch(url, options) and fetch(Request, options) signatures.\n * Priority: init headers > Request headers\n *\n * @param {string | URL | Request} resource - The URL or Request object\n * @param {RequestInit} [init] - Optional fetch options\n * @returns {{ retryer: Retryer | null }}\n */\nfunction getRetryer(resource, init) {\n  // Determine if resource is Request object (for header extraction)\n  const isRequestObject = resource instanceof Request;\n\n  // Extract fetch ID from headers (priority: init headers > Request headers)\n  let fetchId = null;\n  let headersToClean = null;\n\n  // Check init headers first\n  if (init?.headers) {\n    fetchId =\n      init.headers instanceof Headers\n        ? init.headers.get(FetchIdHeader)\n        : init.headers?.[FetchIdHeader];\n\n    if (fetchId) {\n      headersToClean = init.headers;\n    }\n  }\n\n  // Check Request headers if not found in init\n  if (!fetchId && isRequestObject) {\n    fetchId = resource.headers.get(FetchIdHeader);\n    if (fetchId) {\n      // Request.headers is readonly, cannot clean it\n      headersToClean = null;\n    }\n  }\n\n  // If no fetch ID found, return null retryer\n  if (!fetchId) {\n    return { retryer: null };\n  }\n\n  // Remove FetchIdHeader from headers (if mutable)\n  if (headersToClean) {\n    if (headersToClean instanceof Headers) {\n      headersToClean.delete(FetchIdHeader);\n    } else if (typeof headersToClean === \"object\") {\n      delete headersToClean[FetchIdHeader];\n    }\n  }\n\n  // Find associated element\n  const element = FetchIdToElement.get(fetchId);\n\n  // Clean up FetchIdToElement map\n  FetchIdToElement.delete(fetchId);\n\n  // Validate element exists\n  if (!element) {\n    InterceptorLogger.error(\n      \"[Interceptor] No element found for fetchId:\",\n      fetchId\n    );\n    return { retryer: null };\n  }\n\n  // Validate element is still in DOM\n  if (!document.contains(element)) {\n    InterceptorLogger.error(\n      \"[Interceptor] Element for fetchId is no longer in DOM:\",\n      fetchId,\n      element\n    );\n    return { retryer: null };\n  }\n\n  // Find and validate retryer\n  const retryer = ElementIndex.get(element);\n  if (!retryer || !(retryer instanceof Retryer)) {\n    InterceptorLogger.error(\n      \"[Interceptor] No Retryer instance found for element:\",\n      element\n    );\n    return { retryer: null };\n  }\n\n  return { retryer };\n}\n"],
  "mappings": "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",
  "names": ["FetchIdHeader"]
}
